#include "GameEngine.h"

#include <windowsx.h>
#include <cassert>
#include <cstdio>
#include <ctime>

const char* WINDOW_CLASS_NAME = "_unimportant_title_";

enum InputEvent
{
    INPUT_KEYDOWN,
    INPUT_KEYUP,
};

LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

GameEngine::GameEngine()
{
    _hWnd = NULL;
    _hDC = NULL;
    _hPen = NULL;
    _hBrush = NULL;
    _hMemDC = NULL;
    _hBmp = NULL;
    _hInstance = GetModuleHandle(0);
    _bActive = false;
    _iSeed = 0;
    _iLastTime = 0;
    _iFixedDelta = 0;
    _iScreenWidth = 800;
    _iScreenHeight = 600;
    _procExitFunc = NULL;
    _procFrameFunc = NULL;
    _procRenderFunc = NULL;
    memset(_keys, 0, sizeof(_keys));
    memset(_szError, 0, sizeof(_szError));
    memset(_szLogFile, 0, sizeof(_szLogFile));
    memset(_szWinTitle, 0, sizeof(_szWinTitle));
}

GameEngine::~GameEngine()
{
}

bool GameEngine::Initiate()
{
    Log("Initiate...");

    _hBackBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);

    WNDCLASSEX winclass;
    ZeroMemory(&winclass, sizeof(winclass));
    winclass.cbSize = sizeof(winclass);
    winclass.style = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
    winclass.hInstance      = _hInstance;
    winclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    winclass.hbrBackground  = _hBackBrush;
    winclass.lpfnWndProc    = WindowProc;
    winclass.lpszClassName  = WINDOW_CLASS_NAME;
    winclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
    if (!RegisterClassEx(&winclass)) {
        Log("Can't register window class!");
        return false;
    }

    int iWinWidth = _iScreenWidth + GetSystemMetrics(SM_CXFIXEDFRAME) * 2;
    int iWinHeight = _iScreenHeight + GetSystemMetrics(SM_CYFIXEDFRAME) * 2 + GetSystemMetrics(SM_CYCAPTION);
    int iWinLeft = (GetSystemMetrics(SM_CXSCREEN) - iWinWidth) / 2;
    int iWinTop = (GetSystemMetrics(SM_CYSCREEN) - iWinHeight) / 2;
    int iWinStyle = WS_POPUP|WS_SYSMENU|WS_CAPTION|WS_MINIMIZEBOX|WS_VISIBLE;
    SetLastError(0);
    _hWnd = CreateWindowEx(0, WINDOW_CLASS_NAME, _szWinTitle, iWinStyle, iWinLeft, iWinTop, iWinWidth, iWinHeight, NULL, NULL, _hInstance, NULL);
    if (_hWnd == NULL) {
        Log("Can't create window, error %d", GetLastError());
        return false;
    }

    ShowWindow(_hWnd, SW_SHOW);

    timeBeginPeriod(1);
    RandomSeed();
    _InputInit();

    Log("Initiate Finished.");

    return true;
}

void GameEngine::Shutdown()
{
    Log("Finishing...");

    timeEndPeriod(1);

    if (_hBmp != NULL) {
        DeleteObject(_hBmp);
        _hBmp = NULL;
    }

    if (_hMemDC != NULL) {
        DeleteObject(_hMemDC);
        _hMemDC = NULL;
    }

    if (_hDC != NULL) {
        ReleaseDC(_hWnd, _hDC);
    }

    if (_hWnd != NULL) {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }

    if (_hInstance != NULL) {
        UnregisterClass(WINDOW_CLASS_NAME, _hInstance);
        _hInstance = NULL;
    }

    Log("The End.");
}

bool GameEngine::Start()
{
    if (_hWnd == NULL) {
        Log("Start: Initiate wasn't called");
        return false;
    }
    else if (_procFrameFunc == NULL) {
        Log("Start: No frame function defined");
        return false;
    }
    
    GetClientRect(_hWnd, &_rcClient);
    int iWidth = _rcClient.right - _rcClient.left;
    int iHeight = _rcClient.bottom - _rcClient.top;
    _hDC = GetDC(_hWnd);
    _hMemDC = CreateCompatibleDC(_hDC);
    _hBmp = CreateCompatibleBitmap(_hDC, iWidth, iHeight);
    SelectObject(_hMemDC, _hBmp);

    // main loop
    for (;;) {
        MSG msg;
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                break;
            }
            // TranslateMessage(&msg);
            DispatchMessage(&msg);
            continue;
        }

        if (_bActive) {
            // Ensure we have at least 1ms time step
            int iDeltaMs = 0;
            do {
                iDeltaMs = timeGetTime() - _iLastTime;
            } while (iDeltaMs < 1);

            // If we reached the time for the next frame, then do the stuff
            if (iDeltaMs >= _iFixedDelta) {
                // Store current time for the next frame
                _iLastTime = timeGetTime();

                // call user's logic stuff
                if (CallFunc(GEK_FRAMEFUNC)) {
                    break;
                }

                // call user's render stuff
                if (CallFunc(GEK_RENDERFUNC)) {
                    break;
                }

                // Clean up events that were generated by 
                // WindowProc and weren't handled by user's code
                _ClearEvents();
            }
            // If time for the next frame isn't too close, sleep a bit
            else {
                if (iDeltaMs + 3 < _iFixedDelta) {
                    Sleep(1);
                }
            }
        }
        else {
            Sleep(1);
        }
    }

    _ClearEvents();

    _bActive = false;

    return true;
}

void GameEngine::RandomSeed(int iSeed)
{
    srand(time(NULL));
    if (iSeed == 0) {
        _iSeed = timeGetTime();
    }
    else {
        _iSeed = iSeed;
    }
}

int GameEngine::RandomInt(int iMax)
{
    return RandomInt(0, iMax);
}

int GameEngine::RandomInt(int iMin, int iMax)
{
    _iSeed = 21403 * _iSeed + 2531011;
    return iMin + (_iSeed ^ _iSeed>>15) % (iMax - iMin + 1);
}

void GameEngine::ChangeFocus(bool bActive)
{
    _bActive = bActive;
}

void GameEngine::BuildEvent(int iType, int iKey, int iScan, bool isRepeated)
{
    switch (iType) {
        case INPUT_KEYDOWN:
            //if (!isRepeated) {
                _keys[iKey] |= 1;
            //}
            break;
        case INPUT_KEYUP:
            _keys[iKey] |= 2;
            break;
        default:
            assert(false);
            break;
    }
}

bool GameEngine::IsKeyUp(KeyCode eCode) const
{
    return (_keys[eCode] & 0x2) != 0;
}

bool GameEngine::IsKeyDown(KeyCode eCode) const
{
    return (_keys[eCode] & 0x1) != 0;
}

void GameEngine::Log(const char* szFormat, ...)
{
    if (_szLogFile == NULL) {
        return;
    }

    FILE* hfile = fopen(_szLogFile, "a");
    if (hfile == NULL) {
        return;
    }

    va_list ap;
    va_start(ap, szFormat);
    vfprintf(hfile, szFormat, ap);
    va_end(ap);

    fprintf(hfile, "\n");

    fclose(hfile);
}
    
void GameEngine::SetValue(GAME_ENGINE_KEY eKey, int iValue)
{
    switch (eKey) {
        case GEK_FPS:
            _iFixedDelta = 1000 / iValue;
            break;
        case GEK_SCREENWIDTH:
            _iScreenWidth = iValue;
            break;
        case GEK_SCREENHEIGHT:
            _iScreenHeight = iValue;
            break;
        default:
            assert(false);
            break;
    }
}

void GameEngine::SetValue(GAME_ENGINE_KEY eKey, const char* szValue)
{
    switch (eKey) {
        case GEK_LOGFILE:
            strncpy(_szLogFile, szValue, sizeof(_szLogFile));
            break;
        case GEK_WINTITLE:
            strncpy(_szWinTitle, szValue, sizeof(_szWinTitle));
            break;
        default:
            assert(false);
            break;
    }
}
    
void GameEngine::SetValue(GAME_ENGINE_KEY eKey, bool (*pfunc)())
{
    switch (eKey) {
        case GEK_FRAMEFUNC:
            _procFrameFunc = pfunc;
            break;
        case GEK_RENDERFUNC:
            _procRenderFunc = pfunc;
            break;
        default:
            assert(false);
            break;
    }
}
    
int GameEngine::GetIntValue(GAME_ENGINE_KEY eKey)
{
    switch (eKey)
    {
        case GEK_SCREENWIDTH:
            return _iScreenWidth;
        case GEK_SCREENHEIGHT:
            return _iScreenHeight;
        default:
            assert(false);
            return -1;
    }
}

bool GameEngine::CallFunc(GAME_ENGINE_KEY eKey)
{
    bool (*func)() = NULL;
    switch (eKey) {
        case GEK_EXITFUNC:
            func = _procExitFunc;
            break;
        case GEK_FRAMEFUNC:
            func = _procFrameFunc;
            break;
        case GEK_RENDERFUNC:
            // special case
            return _CallRenderFunc();
        default:
            assert(false);
            return false;
    }

    if (func != NULL) {
        return (*func)();
    }
    else {
        return false;
    }
}
    
void GameEngine::DrawText(int x, int y, int iSize, const Color& color, const char* pszFormat, ...)
{ 
    char szText[200];
    va_list ap;
    va_start(ap, pszFormat);
    vsprintf(szText, pszFormat, ap);
    va_end(ap);

    LOGFONT lf;
    ZeroMemory(&lf, sizeof(lf));
    lf.lfHeight = iSize;

    HFONT hFont = CreateFontIndirect(&lf);
    SetBkMode(_hMemDC, TRANSPARENT);
    SetTextColor(_hMemDC, RGB(color.R, color.G, color.B));
    SelectObject(_hMemDC, hFont);

    TextOut(_hMemDC, x, y, szText, strlen(szText));

    DeleteObject(hFont);
}

void GameEngine::DrawLine(int iStartX, int iStartY, int iEndX, int iEndY)
{
    MoveToEx(_hMemDC, iStartX, iStartY, NULL);
    LineTo(_hMemDC, iEndX, iEndY);
}
    
void GameEngine::DrawRect(int iStartX, int iStartY, int iEndX, int iEndY)
{
    Rectangle(_hMemDC, iStartX, iStartY, iEndX, iEndY);
}
    
void GameEngine::PreparePen(int iWidth, PenStyle eStyle, const Color& color)
{
    _hPen = CreatePen(eStyle, iWidth, RGB(color.R, color.G, color.B));
    SelectPen(_hMemDC, _hPen);
}

void GameEngine::ReleasePen()
{
    DeletePen(_hPen);
    _hPen = NULL;
}

void GameEngine::PrepareBrush(const Color& color)
{
    _hBrush = CreateSolidBrush(RGB(color.R, color.G, color.B));
    SelectBrush(_hMemDC, _hBrush);
}

void GameEngine::ReleaseBrush()
{
    DeleteBrush(_hBrush);
}

GameEngine* GameEngine::instance()
{
    static GameEngine s_engine;
    return &s_engine;
}

void GameEngine::_InputInit()
{
    memset(_keys, 0, sizeof(_keys));
}
    
void GameEngine::_ClearEvents()
{
    memset(&_keys, 0, sizeof(_keys));
}
    
bool GameEngine::_CallRenderFunc()
{
    int iWidth = _rcClient.right - _rcClient.left;
    int iHeight = _rcClient.bottom - _rcClient.top;

    FillRect(_hMemDC, &_rcClient, _hBackBrush);
    bool result = (_procRenderFunc != NULL) ? (*_procRenderFunc)() : false;

    BitBlt(_hDC, 0, 0, iWidth, iHeight, _hMemDC, 0, 0, SRCCOPY);

    return result;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
        case WM_CREATE:
            return FALSE;

        case WM_PAINT:
            GameEngine::instance()->CallFunc(GEK_RENDERFUNC);
            break;  ///< why not return?

        case WM_DESTROY:
            PostQuitMessage(0);
            return FALSE;

        case WM_ACTIVATE:
            {
                bool bActive = (LOWORD(wparam)!=WA_INACTIVE) && (HIWORD(wparam)==0);
                GameEngine::instance()->ChangeFocus(bActive);
            }
            return FALSE;

        case WM_SYSKEYDOWN:
            if (wparam == VK_F4) {
                if (GameEngine::instance()->CallFunc(GEK_EXITFUNC)) {
                    return FALSE;
                }
                else {
                    break;
                }
            }
            else {
                GameEngine::instance()->BuildEvent(INPUT_KEYDOWN, wparam, HIWORD(lparam) & 0xFF, (lparam&0x40000000) != 0);
                return FALSE;
            }
        case WM_KEYDOWN:
            GameEngine::instance()->BuildEvent(INPUT_KEYDOWN, wparam, HIWORD(lparam)&0xFF, (lparam&0x40000000) != 0);
            return FALSE;
        case WM_SYSKEYUP:
        case WM_KEYUP:
            GameEngine::instance()->BuildEvent(INPUT_KEYUP, wparam, HIWORD(lparam)&0xFF, false);
            return FALSE;
        case WM_SYSCOMMAND:
            if (wparam == SC_CLOSE) {
                if (GameEngine::instance()->CallFunc(GEK_EXITFUNC)) {
                    return FALSE;
                }
            }
            break;
        default:
            break;
    }

    return DefWindowProc(hwnd, msg, wparam, lparam);
}
